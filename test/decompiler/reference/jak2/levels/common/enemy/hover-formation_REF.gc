;;-*-Lisp-*-
(in-package goal)

;; definition for method 12 of type hover-formation-control
(defmethod is-formation-type-in-range hover-formation-control ((obj hover-formation-control))
  (case (-> obj formation-type)
    (((formation-type unknown-2) (formation-type unknown-3) (formation-type unknown-0))
     #f
     )
    (else
      #t
      )
    )
  )

;; definition for method 16 of type hover-formation-control
;; ERROR: function was not converted to expressions. Cannot decompile.

;; definition for method 9 of type hover-formation-control
(defmethod set-anchor-proc hover-formation-control ((obj hover-formation-control) (arg0 handle))
  (set! (-> obj anchor-proc) arg0)
  0
  )

;; definition for method 13 of type hover-formation-control
;; ERROR: function was not converted to expressions. Cannot decompile.

;; definition for method 14 of type hover-formation-control
;; ERROR: function was not converted to expressions. Cannot decompile.

;; definition for method 15 of type hover-formation-control
(defmethod hover-formation-control-method-15 hover-formation-control ((obj hover-formation-control) (arg0 vector) (arg1 vector))
  (vector-matrix*!
    arg0
    (hover-formation-control-method-13 obj (new 'stack-no-clear 'vector))
    (-> obj world-to-zone)
    )
  (vector+! arg0 arg0 arg1)
  (vector-matrix*! arg0 arg0 (-> obj zone-to-world))
  )

;; definition for function odd?
(defun odd? ((arg0 int))
  (= (logand arg0 1) 1)
  )

;; definition for function even?
(defun even? ((arg0 int))
  (not (odd? arg0))
  )

;; definition of type gen-perms-context
(deftype gen-perms-context (structure)
  ((num           int32   :offset-assert   0)
   (table         uint32  :offset-assert   4)
   (iterate-count int32   :offset-assert   8)
   )
  :method-count-assert 9
  :size-assert         #xc
  :flag-assert         #x90000000c
  )

;; definition for method 3 of type gen-perms-context
(defmethod inspect gen-perms-context ((obj gen-perms-context))
  (when (not obj)
    (set! obj obj)
    (goto cfg-4)
    )
  (format #t "[~8x] ~A~%" obj 'gen-perms-context)
  (format #t "~1Tnum: ~D~%" (-> obj num))
  (format #t "~1Ttable: #x~X~%" (-> obj table))
  (format #t "~1Titerate-count: ~D~%" (-> obj iterate-count))
  (label cfg-4)
  obj
  )

;; definition for function gen-perms
;; INFO: Used lq/sq
(defun gen-perms ((arg0 int)
         (arg1 (function int int (function vector none) none))
         (arg2 (function vector object))
         (arg3 vector)
         )
  (local-vars (sv-80 int))
  (let ((s2-0 (new 'stack-no-clear 'gen-perms-context)))
    (dotimes (v1-0 arg0)
      (set! (-> (the-as (pointer int32) (+ (the-as uint s2-0) (* v1-0 4)))) 0)
      )
    (arg2 arg3)
    (let ((s1-0 1))
      (while (< s1-0 arg0)
        (cond
          ((>= (-> (the-as (pointer int32) (+ (the-as uint s2-0) (* s1-0 4)))) s1-0)
           (set! (-> (the-as (pointer int32) (+ (the-as uint s2-0) (* s1-0 4)))) 0)
           0
           )
          (else
            (let ((s0-0 arg1))
              (set! sv-80 s1-0)
              (let ((a1-1 (if (odd? s1-0)
                              (-> (the-as (pointer int32) (+ (the-as uint s2-0) (* s1-0 4))))
                              0
                              )
                          )
                    (a2-1 arg3)
                    )
                (s0-0 sv-80 a1-1 (the-as (function vector none) a2-1))
                )
              )
            (+! (-> (the-as (pointer int32) (+ (the-as uint s2-0) (* s1-0 4)))) 1)
            (arg2 arg3)
            (set! s1-0 0)
            )
          )
        (+! s1-0 1)
        )
      )
    )
  #f
  )

;; definition for function test-gen-perms
(defun test-gen-perms ((arg0 int))
  (let ((gp-0 (new 'stack-no-clear 'gen-perms-context))
        (s4-0 (new 'stack 'gen-perms-context))
        )
    (dotimes (v1-1 arg0)
      (set! (-> (the-as (pointer int32) (+ (the-as uint gp-0) (* v1-1 4)))) v1-1)
      )
    (set! (-> s4-0 num) arg0)
    (set! (-> s4-0 table) (the-as uint gp-0))
    (set! (-> s4-0 iterate-count) 0)
    (gen-perms
      arg0
      (the-as
        (function int int (function vector none) none)
        (lambda ((arg0 int) (arg1 int) (arg2 (pointer object)))
          (let ((v0-0 (-> (the-as (pointer int32) (+ (the-as uint (-> arg2 1)) (* arg0 4))))))
            (set! (-> (the-as (pointer int32) (+ (the-as uint (-> arg2 1)) (* arg0 4))))
                  (-> (the-as (pointer int32) (+ (the-as uint (-> arg2 1)) (* arg1 4))))
                  )
            (set! (-> (the-as (pointer int32) (+ (the-as uint (-> arg2 1)) (* arg1 4)))) v0-0)
            v0-0
            )
          )
        )
      (lambda ((arg0 vector))
        (format #t "(")
        (dotimes (s5-0 (the-as int (-> arg0 x)))
          (format #t "~d " (-> (the-as (pointer int32) (+ (the-as uint (-> arg0 y)) (* s5-0 4)))))
          )
        (format #t ")~%")
        )
      (the-as vector s4-0)
      )
    (format #t "iterate-count: ~d~%" (-> s4-0 iterate-count))
    )
  )

;; definition for method 10 of type hover-formation-control
;; ERROR: function was not converted to expressions. Cannot decompile.

;; definition for method 11 of type hover-formation-control
;; INFO: Used lq/sq
;; ERROR: failed type prop at 48: Could not figure out load: (set! v1 (l.q v1))
;; ERROR: Unsupported inline assembly instruction kind - [sllv a0, v1, r0]
;; ERROR: Unsupported inline assembly instruction kind - [sllv a0, v1, r0]
(defmethod hover-formation-control-method-11 hover-formation-control ((a0-0 hover-formation-control))
  (local-vars
    (v0-0 symbol)
    (v0-1 none)
    (v0-2 none)
    (v0-3 none)
    (v0-4 none)
    (v0-5 vector)
    (v0-6 vector)
    (v0-7 symbol)
    (v0-8 object)
    (v0-9 int)
    (v1-0 hover-formation-control)
    (v1-1 int)
    (v1-2 int)
    (v1-3 int)
    (v1-4 handle)
    (v1-5 int)
    (v1-7 int)
    (v1-8 int)
    (v1-9 type)
    (v1-10 none)
    (v1-11 none)
    (v1-12 none)
    (v1-13 none)
    (v1-14 none)
    (v1-15 none)
    (v1-16 none)
    (v1-18 none)
    (v1-19 none)
    (v1-20 none)
    (v1-21 none)
    (v1-24 int)
    (v1-25 int)
    (v1-26 type)
    (v1-27 none)
    (v1-29 uint)
    (v1-30 uint)
    (v1-32 type)
    (v1-33 none)
    (v1-35 uint)
    (v1-36 uint)
    (v1-38 type)
    (v1-39 none)
    (v1-41 uint)
    (v1-42 uint)
    (v1-44 symbol)
    (v1-45 int)
    (v1-48 int)
    (v1-49 int)
    (v1-51 uint)
    (v1-52 int)
    (v1-53 int)
    (v1-54 int)
    (v1-55 int)
    (v1-58 type)
    (v1-59 int)
    (v1-60 int)
    (v1-61 uint)
    (v1-63 int)
    (v1-66 int)
    (v1-69 int)
    (v1-70 int)
    (v1-71 handle)
    (v1-72 int)
    (a0-1 int)
    (a0-4 int)
    (a0-5 (pointer process))
    (a0-6 process)
    (a0-7 process)
    (a0-8 basic)
    (a0-9 none)
    (a0-10 none)
    (a0-11 hover-formation-control)
    (a0-12 int)
    (a0-13 none)
    (a0-14 none)
    (a0-15 hover-formation-control)
    (a0-16 int)
    (a0-17 none)
    (a0-18 none)
    (a0-19 hover-formation-control)
    (a0-20 int)
    (a0-21 none)
    (a0-22 none)
    (a0-23 symbol)
    (a0-24 int)
    (a0-25 uint)
    (a0-26 hover-formation-control)
    (a0-27 int)
    (a0-28 int)
    (a0-30 process)
    (a0-31 int)
    (a0-32 symbol)
    (a0-33 uint)
    (a0-34 uint)
    (a0-35 int)
    (a0-36 process)
    (a0-37 (pointer process))
    (a0-38 int)
    (a1-0 hover-formation-control)
    (a1-1 hover-formation-control)
    (a1-2 int)
    (a1-3 type)
    (a1-4 int)
    (a1-5 none)
    (a1-6 none)
    (a1-7 none)
    (a1-8 vector)
    (a1-9 vector)
    (a1-10 (function object object (pointer hover-formation) hover-formation))
    (a1-11 hover-formation-control)
    (a2-0 vector)
    (a2-1 vector)
    (a2-2 vector)
    (a2-3 int)
    (a2-4 int)
    (a2-5 uint)
    (a2-6 (function (array float) float))
    (a2-7 (pointer process))
    (a2-8 int)
    (a2-9 int)
    (a2-10 uint)
    (a2-11 uint)
    (a2-12 process)
    (a3-0 float)
    (a3-1 float)
    (a3-2 float)
    (a3-3 form-search-info)
    (s1-0 int)
    (s2-0 none)
    (s3-0 process)
    (s3-1 vector)
    (s3-2 int)
    (s3-3 int)
    (s3-4 int)
    (s4-0 int)
    (s4-1 int)
    (s4-2 int)
    (s4-3 int)
    (s5-0 form-search-info)
    (t9-0 (function object type symbol))
    (t9-1 (function none))
    (t9-2 (function hover-formation-control vector vector float none))
    (t9-3 (function hover-formation-control vector vector float none))
    (t9-4 (function hover-formation-control vector vector float none))
    (t9-5 (function vector vector float vector))
    (t9-6 (function hover-formation-control vector vector vector))
    (t9-7 (function int (function int int (function vector none) none) (function vector object) vector symbol))
    (t9-8 (function process-tree event-message-block object))
    (f0-0 float)
    (f0-1 float)
    (f0-2 float)
    (f0-3 int)
    (f0-4 float)
    (f0-5 int)
    (f0-6 float)
    (f0-7 float)
    (f0-8 float)
    (f28-0 float)
    (f28-1 number)
    (f30-0 float)
    )
  (with-pp
    (set! s5-0 (-> a0-0 search-info))
    (set! (-> s5-0 form) (the-as uint a0-0))
    (set! v1-0 (new 'stack-no-clear 'hover-formation-control))
    (set! a0-1 0)
    (while (<.si a0-1 16)
      (set! a1-0 (the-as hover-formation-control (sll a0-1 4)))
      (set! a1-1 (the-as hover-formation-control (+ v1-0 a1-0)))
      (s.q! a1-1 0)
      (set! a0-1 (the-as int (+ a0-1 1)))
      )
    (set! (-> s5-0 pos-table) (the-as uint v1-0))
    (set! v1-1 -1082130432)
    (set! f0-0 (the-as float (gpr->fpr v1-1)))
    (set! (-> s5-0 best-cost) f0-0)
    (set! (-> s5-0 count) 0)
    (set! s4-0 0)
    (while (<.si s4-0 16)
      (if (begin
            (and (begin
                   (set! v1-2 (sll s4-0 3))
                   (set! v1-3 (+ v1-2 a0-0))
                   (set! v1-4 (dynamic-array-field-access v1-3 actor-table PLACEHOLDER))
                   (set! a0-4 (subu-s7 v1-4))
                   (nonzero? a0-4)
                   )
                 (begin
                   (if (begin
                         (.sllv a0-5 v1-4 r0)
                         (set! a0-6 (-> a0-5 0))
                         (set! a1-2 (-> a0-6 pid))
                         (set! v1-5 (sra v1-4 32))
                         (= v1-5 a1-2)
                         )
                       (set! s3-0 a0-6)
                       )
                   (set! v1-6 s3-0)
                   )
                 )
            (set! t9-0 type?)
            (set! a0-7 s3-0)
            (set! a1-3 process-focusable)
            (set! v0-0 (call! a0-7 a1-3))
            v0-0
            )
          (set! a0-8 s3-0)
          )
      (cond
        (a0-8
          (set! v1-7 (sll s4-0 4))
          (set! v1-8 (+ v1-7 16))
          (set! s3-1 (+ v1-8 s5-0))
          (set! v1-9 (-> a0-8 type))
          (set! t9-1 (method-of-type v1-9 hover-formation-control-method-20))
          (set! a1-4 3)
          (set! v0-1 (call!))
          (set! v1-10 v0-1)
          (set! v1-11 (the-as none (l.q v1-10)))
          (set! (-> s3-1 quad) (the-as uint128 v1-11))
          (set! v1-12 (the-as none #t))
          (set! a0-9 (the-as none (sll s4-0 2)))
          (set! a0-10 (the-as none (+ a0-9 s5-0)))
          (s.w! (+ a0-10 272) v1-12)
          (set! v1-13 (the-as none (-> s5-0 count)))
          (set! v1-14 (the-as none (+ v1-13 1)))
          (set! (-> s5-0 count) (the-as int v1-14))
          )
        (else
          (set! v1-15 (the-as none (sll s4-0 2)))
          (set! v1-16 (the-as none (+ v1-15 s5-0)))
          (s.w! (+ v1-16 272) #f)
          )
        )
      (set! v1-18 (the-as none (sll s4-0 2)))
      (set! v1-19 (the-as none (+ v1-18 s5-0)))
      (s.w! (+ v1-19 336) s4-0)
      (set! v1-20 (the-as none (sll s4-0 2)))
      (set! v1-21 (the-as none (+ v1-20 s5-0)))
      (s.w! (+ v1-21 656) s4-0)
      (set! s4-0 (the-as int (+ s4-0 1)))
      )
    (when (begin
            (set! f30-0 (-> a0-0 rotation-inc))
            (set! f28-0 f30-0)
            (set! v1-24 #x47800000)
            (set! f0-1 (the-as float (gpr->fpr v1-24)))
            (set! f0-2 (/.s f0-1 f30-0))
            (set! f0-3 (f2i f0-2))
            (set! v1-25 (fpr->gpr f0-3))
            (set! s3-2 (+ v1-25 1))
            (set! s4-1 0)
            (set! s2-0 (the-as none (new 'stack-no-clear 'vector)))
            (set! a0-11 a0-0)
            (set! v1-26 (-> a0-11 type))
            (set! t9-2 (method-of-type v1-26 hover-formation-control-method-10))
            (set! a1-5 (the-as none s2-0))
            (set! a2-0 (-> a0-0 offset))
            (set! a3-0 (the-as float 0))
            (set! v0-2 (call! a0-11 a1-5 a2-0 a3-0))
            (set! v1-27 v0-2)
            v1-27
            )
      (set! v1-29 (-> s5-0 pos-table))
      (set! a0-12 (sll s4-1 4))
      (set! v1-30 (+ v1-29 a0-12))
      (set! a0-13 (the-as none s2-0))
      (set! a0-14 (the-as none (l.q a0-13)))
      (s.q! v1-30 a0-14)
      (set! s4-1 (+ s4-1 1))
      (set! v1-31 s4-1)
      )
    (set! s1-0 0)
    (while (begin
             (or (begin (set! a0-23 (>=.si s1-0 s3-2)) a0-23)
                 (begin (set! v1-45 (-> s5-0 count)) (set! v1-44 (>=.si s4-1 v1-45)))
                 )
             (not v1-44)
             )
      (when (begin
              (when (begin
                      (set! a0-15 a0-0)
                      (set! v1-32 (-> a0-15 type))
                      (set! t9-3 (method-of-type v1-32 hover-formation-control-method-10))
                      (set! a1-6 (the-as none s2-0))
                      (set! a2-1 (-> a0-0 offset))
                      (set! a3-1 (fpr->gpr f28-0))
                      (set! v0-3 (call! a0-15 a1-6 a2-1 a3-1))
                      (set! v1-33 v0-3)
                      v1-33
                      )
                (set! v1-35 (-> s5-0 pos-table))
                (set! a0-16 (sll s4-1 4))
                (set! v1-36 (+ v1-35 a0-16))
                (set! a0-17 (the-as none s2-0))
                (set! a0-18 (the-as none (l.q a0-17)))
                (s.q! v1-36 a0-18)
                (set! s4-1 (+ s4-1 1))
                (set! v1-37 s4-1)
                )
              (set! a0-19 a0-0)
              (set! v1-38 (-> a0-19 type))
              (set! t9-4 (method-of-type v1-38 hover-formation-control-method-10))
              (set! a1-7 (the-as none s2-0))
              (set! a2-2 (-> a0-0 offset))
              (set! f0-4 (neg.s f28-0))
              (set! a3-2 (fpr->gpr f0-4))
              (set! v0-4 (call! a0-19 a1-7 a2-2 a3-2))
              (set! v1-39 v0-4)
              v1-39
              )
        (set! v1-41 (-> s5-0 pos-table))
        (set! a0-20 (sll s4-1 4))
        (set! v1-42 (+ v1-41 a0-20))
        (set! a0-21 (the-as none s2-0))
        (set! a0-22 (the-as none (l.q a0-21)))
        (s.q! v1-42 a0-22)
        (set! s4-1 (+ s4-1 1))
        (set! v1-43 s4-1)
        )
      (set! f28-0 (+.s f28-0 f30-0))
      (set! s1-0 (+ s1-0 1))
      )
    (when (begin
            (when (begin (set! v1-48 (-> s5-0 count)) (set! v1-49 (- v1-48 s4-1)) (>0.si v1-49))
              (set! f28-1 0)
              (set! s3-3 0)
              (while (begin (set! v1-54 (-> s5-0 count)) (set! v1-55 (- v1-54 s4-1)) (<.si s3-3 v1-55))
                (set! t9-5 vector-rotate-y!)
                (set! v1-51 (-> s5-0 pos-table))
                (set! a0-24 (sll s3-3 4))
                (set! a0-25 (+ v1-51 a0-24))
                (set! a1-8 (-> a0-0 offset))
                (set! a2-3 (fpr->gpr f28-1))
                (call! a0-25 a1-8 a2-3)
                (set! v1-52 (+ s3-3 1))
                (set! f0-5 (gpr->fpr v1-52))
                (set! f0-6 (i2f f0-5))
                (set! f0-7 (*.s f0-6 f30-0))
                (set! f28-1 (+.s f28-1 f0-7))
                (set! v1-53 -1082130432)
                (set! f0-8 (the-as float (gpr->fpr v1-53)))
                (set! f30-0 (*.s f0-8 f30-0))
                (set! s3-3 (+ s3-3 1))
                )
              )
            (set! s4-2 0)
            (while (begin (set! v1-63 (-> s5-0 count)) (<.si s4-2 v1-63))
              (set! a0-26 a0-0)
              (set! v1-58 (-> a0-26 type))
              (set! t9-6 (method-of-type v1-58 hover-formation-control-method-15))
              (set! v1-59 (sll s4-2 4))
              (set! v1-60 (+ v1-59 400))
              (set! a1-9 (+ v1-60 s5-0))
              (set! v1-61 (-> s5-0 pos-table))
              (set! a2-4 (sll s4-2 4))
              (set! a2-5 (+ v1-61 a2-4))
              (call! a0-26 a1-9 a2-5)
              (set! v1-62 v0-6)
              (set! s4-2 (+ s4-2 1))
              )
            (set! v1-66 1)
            (set! a0-27 (-> s5-0 count))
            (<.si v1-66 a0-27)
            )
      (set! t9-7 gen-perms)
      (set! a0-28 (-> s5-0 count))
      (set! a1-10
            (lambda ((arg0 object) (arg1 object) (arg2 (pointer hover-formation)))
              (let ((v0-0 (-> (+ (* arg0 4) (the-as int arg2)) 84)))
                (set! (-> (+ (* arg0 4) (the-as int arg2)) 84) (-> (+ (* arg1 4) (the-as int arg2)) 84))
                (set! (-> (+ (* arg1 4) (the-as int arg2)) 84) v0-0)
                v0-0
                )
              )
            )
      (set! a2-6
            (lambda ((arg0 (array float)))
              (let ((s5-0 0)
                    (f30-0 0.0)
                    )
                (dotimes (s4-0 (-> arg0 allocated-length))
                  (when (l.wu (+ (* s4-0 4) (the-as int arg0) 272))
                    (+! f30-0 (vector-vector-distance
                                (the-as vector (+ (+ (* s4-0 16) 16) (the-as int arg0)))
                                (the-as vector (+ (+ (* (l.wu (+ (* s5-0 4) (the-as int arg0) 336)) 16) 400) (the-as uint arg0)))
                                )
                        )
                    (+! s5-0 1)
                    )
                  )
                (when (or (= (-> arg0 177) -1.0) (< f30-0 (-> arg0 177)))
                  (dotimes (v1-18 16)
                    (let ((a0-4 (l.wu (+ (* v1-18 4) (the-as int arg0) 336)))
                          (a1-2 (+ (* v1-18 4) (the-as int arg0)))
                          )
                      (s.w! (+ a1-2 656) a0-4)
                      )
                    )
                  (set! (-> arg0 177) f30-0)
                  f30-0
                  )
                )
              )
            )
      (set! a3-3 s5-0)
      (call! a0-28 a1-10 a2-6 a3-3)
      (set! v1-68 v0-7)
      )
    (set! s4-3 0)
    (set! s3-4 0)
    (while (<.si s3-4 16)
      (when (begin
              (set! v1-69 (sll s3-4 3))
              (set! v1-70 (+ v1-69 a0-0))
              (set! v1-71 (dynamic-array-field-access v1-70 actor-table PLACEHOLDER))
              v1-71
              )
        (and (begin
               (if (begin (set! a1-11 (new 'stack-no-clear 'hover-formation-control)) (set! a0-30 s6-0) a0-30)
                   (set! a2-7 (-> a0-30 ppointer))
                   )
               (s.w! (+ a1-11 8) a2-7)
               (set! a0-31 1)
               (set! (-> a1-11 search-info actor-position 2 z) (the-as float a0-31))
               (set! a0-32 'update-formation)
               (set! (-> a1-11 search-info actor-position 2 y) (the-as float a0-32))
               (set! a0-33 (-> s5-0 pos-table))
               (set! a2-8 (sll s4-3 2))
               (set! a2-9 (+ a2-8 s5-0))
               (set! a2-10 (dynamic-array-field-access a2-9 best-mapping PLACEHOLDER))
               (set! a2-11 (sll a2-10 4))
               (set! a0-34 (+ a0-33 a2-11))
               (s.d! (+ a1-11 16) a0-34)
               (set! t9-8 send-event-function)
               (set! a0-35 (subu-s7 v1-71))
               (nonzero? a0-35)
               )
             (begin
               (if (begin
                     (.sllv a0-37 v1-71 r0)
                     (set! a2-12 (-> a0-37 0))
                     (set! a0-38 (-> a2-12 pid))
                     (set! v1-72 (sra v1-71 32))
                     (= v1-72 a0-38)
                     )
                   (set! a0-36 a2-12)
                   )
               (set! v1-73 a0-36)
               )
             )
        (call! a0-36 a1-11)
        (set! v1-74 v0-8)
        (set! s4-3 (+ s4-3 1))
        (set! a0-39 s4-3)
        )
      (set! s3-4 (+ s3-4 1))
      )
    (set! v0-9 0)
    (ret-value v0-9)
    )
  )

;; definition for method 17 of type hover-formation-control
(defmethod hover-formation-control-method-17 hover-formation-control ((obj hover-formation-control) (arg0 process))
  (let ((v1-2 (process->handle arg0))
        (a2-0 -1)
        (a1-4 -1)
        )
    (dotimes (a3-0 16)
      (when (= v1-2 (-> obj actor-table a3-0))
        (set! a2-0 a3-0)
        (goto cfg-17)
        )
      (if (and (not (-> obj actor-table a3-0)) (= a1-4 -1))
          (set! a1-4 a3-0)
          )
      )
    (label cfg-17)
    (when (= a2-0 -1)
      (cond
        ((= a1-4 -1)
         (format #t "ERROR!!! Too many actors in formation. Currently there is a maximum of ~M. ~%" 16)
         )
        (else
          (when (!= a1-4 -1)
            (set! (-> obj actor-table a1-4) (the-as handle v1-2))
            (hover-formation-control-method-11 obj)
            )
          )
        )
      )
    )
  0
  )

;; definition for method 18 of type hover-formation-control
(defmethod hover-formation-control-method-18 hover-formation-control ((obj hover-formation-control) (arg0 process))
  (let ((v1-2 (process->handle arg0)))
    (dotimes (a1-4 16)
      (when (= v1-2 (-> obj actor-table a1-4))
        (set! (-> obj actor-table a1-4) (the-as handle #f))
        (hover-formation-control-method-11 obj)
        #t
        (goto cfg-12)
        )
      )
    )
  (label cfg-12)
  0
  )

;; definition for method 19 of type hover-formation-control
(defmethod try-update-formation-type hover-formation-control ((obj hover-formation-control) (arg0 formation-type))
  (when (!= (-> obj formation-type) arg0)
    (set! (-> obj formation-type) arg0)
    (hover-formation-control-method-11 obj)
    )
  0
  )

;; definition for method 0 of type hover-formation-control
;; INFO: Used lq/sq
(defmethod new hover-formation-control ((allocation symbol)
                                      (type-to-make type)
                                      (arg0 none)
                                      (arg1 entity)
                                      (arg2 float)
                                      (arg3 vector)
                                      (arg4 float)
                                      (arg5 handle)
                                      )
  (let ((gp-0 (object-new allocation type-to-make (the-as int (-> type-to-make size)))))
    (set! (-> gp-0 entity) arg1)
    (set! (-> gp-0 anchor-proc) arg5)
    (set! (-> gp-0 flags) (the-as uint 0))
    (set! (-> gp-0 notice-dist) arg2)
    (set! (-> gp-0 rotation-inc) arg4)
    (set! (-> gp-0 offset quad) (-> arg3 quad))
    (set! (-> gp-0 center quad) (-> gp-0 entity extra trans quad))
    (quaternion-copy! (-> gp-0 focus-quat) *unity-quaternion*)
    (let ((v1-5 (res-lump-value (-> gp-0 entity) 'options uint128 :time -1000000000.0)))
      (if (logtest? (the-as int v1-5) 256)
          (logior! (-> gp-0 flags) 1)
          )
      (if (logtest? #x20000 v1-5)
          (logior! (-> gp-0 flags) 2)
          )
      )
    (dotimes (v1-10 16)
      (set! (-> gp-0 actor-table v1-10) (the-as handle #f))
      )
    (let ((f0-2 (res-lump-float (-> gp-0 entity) 'rotoffset)))
      (matrix-rotate-y! (-> gp-0 zone-to-world) f0-2)
      )
    (set! (-> gp-0 zone-to-world trans quad) (-> gp-0 center quad))
    (matrix-inverse-of-rot-trans! (-> gp-0 world-to-zone) (-> gp-0 zone-to-world))
    (set! (-> gp-0 formation-type) (formation-type unknown-3))
    gp-0
    )
  )

;; failed to figure out what this is:
(defstate idle (hover-formation)
  :virtual #t
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (local-vars (v0-0 object))
    (the-as object (case event-type
                     (('join)
                      (hover-formation-control-method-17 (-> self formation) proc)
                      )
                     (('leave)
                      (hover-formation-control-method-18 (-> self formation) proc)
                      )
                     (('set-type)
                      (let ((a1-11 1))
                        (case (-> event param 0)
                          (('line)
                           (set! a1-11 0)
                           )
                          (('circle)
                           (set! a1-11 2)
                           )
                          (('semicircle)
                           (set! a1-11 3)
                           )
                          )
                        (try-update-formation-type (-> self formation) (the-as formation-type a1-11))
                        )
                      )
                     (('update-sphere)
                      (let* ((v1-9 (-> self formation))
                             (t9-3 (method-of-object v1-9 hover-formation-control-method-20))
                             )
                        (process->handle proc)
                        (-> event param 0)
                        (the-as object (t9-3))
                        )
                      )
                     (('get-formation)
                      (-> self formation)
                      )
                     (('set-los)
                      (cond
                        ((-> event param 0)
                         (set! v0-0 (logior (-> self formation flags) 2))
                         (set! (-> self formation flags) (the-as uint v0-0))
                         )
                        (else
                          (set! v0-0 (logand -3 (-> self formation flags)))
                          (set! (-> self formation flags) (the-as uint v0-0))
                          )
                        )
                      v0-0
                      )
                     (('path)
                      (if (not (logtest? (-> self path flags) (path-control-flag not-found)))
                          (-> self path)
                          )
                      )
                     )
            )
    )
  :code (the-as (function none :behavior hover-formation) sleep-code)
  :post (behavior ()
    (set-anchor-proc (-> self formation) (process->handle *target*))
    (hover-formation-control-method-14 (-> self formation))
    (when (and (logtest? (-> self formation flags) 2)
               (>= (- (-> self clock frame-counter) (the-as int (-> self formation-timer))) (seconds 0.2))
               )
      (hover-formation-control-method-11 (-> self formation))
      (set! (-> self formation-timer) (the-as uint (-> self clock frame-counter)))
      )
    (if (not (logtest? (-> self path flags) (path-control-flag not-found)))
        (debug-draw (-> self path))
        )
    (none)
    )
  )

;; definition for method 7 of type hover-formation
(defmethod relocate hover-formation ((obj hover-formation) (arg0 int))
  (if (nonzero? (-> obj formation))
      (&+! (-> obj formation) arg0)
      )
  (if (nonzero? (-> obj path))
      (&+! (-> obj path) arg0)
      )
  ((find-parent-method hover-formation 7) (the-as type obj) arg0)
  (none)
  )

;; definition for method 15 of type hover-formation
(defmethod unused-15 hover-formation ()
  0
  )

;; definition for method 11 of type hover-formation
;; INFO: Used lq/sq
;; ERROR: Failed store: (s.f! t0-2 f0-0) at op 50
(defmethod init-from-entity! hover-formation ((obj hover-formation) (arg0 none))
  (local-vars (sv-32 structure))
  (with-pp
    (set! (-> obj path) (new 'process 'path-control obj 'path 0.0 (-> obj entity) #f))
    (logior! (-> obj path flags) (path-control-flag display draw-line draw-point draw-text))
    (let* ((s5-0 (method-of-type hover-formation-control new))
           (s4-0 'process)
           (s3-0 hover-formation-control)
           (s2-0 obj)
           (v0-1 (entity-actor-lookup (-> obj entity) 'alt-actor 0))
           (s1-0 (if v0-1
                     v0-1
                     (-> obj entity)
                     )
                 )
           (s0-0 (res-lump-float (-> obj entity) 'notice-dist :default 225280.0))
           )
      (let ((t9-3 (method-of-type res-lump get-property-struct))
            (a0-5 (-> obj entity))
            (a1-4 'trans-offset)
            (a2-3 'interp)
            (a3-2 -1000000000.0)
            (t0-2 (new 'stack-no-clear 'structure))
            )
        (let ((f0-0 0.0))
          (s.f! t0-2 f0-0)
          )
        (let ((f0-1 20480.0))
          (s.f! (+ t0-2 4) f0-1)
          )
        (let ((f0-2 61440.0))
          (s.f! (+ t0-2 8) f0-2)
          )
        (let ((f0-3 1.0))
          (s.f! (+ t0-2 12) f0-3)
          )
        (set! sv-32 (t9-3 a0-5 a1-4 a2-3 a3-2 t0-2 (the-as (pointer res-tag) #f) *res-static-buf*))
        )
      (let ((t2-4 (res-lump-float (-> obj entity) 'rotoffset :default 5461.3335))
            (t3-0 #f)
            )
        (set! (-> obj formation)
              (s5-0 s4-0 s3-0 (the-as none s2-0) s1-0 s0-0 (the-as vector sv-32) t2-4 (the-as handle t3-0))
              )
        )
      )
    (set! (-> obj formation-timer) (the-as uint (-> pp clock frame-counter)))
    (logclear! (-> obj mask) (process-mask actor-pause))
    (process-entity-status! obj (entity-perm-status no-kill) #t)
    ((method-of-object obj unused-15))
    (go (method-of-object obj idle))
    )
  )
